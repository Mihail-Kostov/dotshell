. "$HOME/.local/lib/sh/print.sh"
. "$HOME/.local/lib/sh/shell.sh"
. "$HOME/.local/lib/sh/file.sh"
. "$HOME/.local/lib/sh/path.sh"
. "$HOME/.local/lib/sh/os.sh"
. "$HOME/.local/lib/sh/alias.sh"
. "$HOME/.local/lib/sh/editor.sh"

shellrc::path_setup() {
    path::prepend /usr/local/bin
    path::prepend /usr/local/sbin

    path::has_binary npm && path::prepend "$(npm prefix --global)/bin"
    path::prepend "/opt/cabal/bin"

    if os::is_darwin; then
        path::prepend /usr/texbin
        path::prepend /opt/X11/bin

        local server_prefix="/Applications/Server.app/Contents/ServerRoot"
        path::prepend "$server_prefix/bin"
        path::prepend "$server_prefix/sbin"

        if path::has_binary brew; then
            local brew_prefix="$(brew --prefix)"
            path::prepend "$brew_prefix/bin"
            path::prepend "$brew_prefix/sbin"

            for binary in ruby python python3 go; do
                if file::is_executable "${brew_prefix}/bin/${binary}"; then
                    path::prepend "$(brew --prefix ${binary})/bin"
                fi
            done
        fi
    fi

    path::prepend "$HOME/.local/bin"
    path::prepend "$HOME/.cask/bin"
    path::prepend "$HOME/.cabal/bin"
    path::prepend "$HOME/bin"
}
shell::eval shellrc::path_setup

shellrc::coding_setup() {
    export LANG="en_US.UTF_8"
    export LC_ALL="en_US.UTF-8"
    # Keep the default sort order (e.g. files starting with a '.'
    # should appear at the start of a directory listing.)
    export LC_COLLATE="C"
    # Set the short date to YYYY-MM-DD (test with "date +%c")
    export LC_TIME="sv_SE.UTF-8"
}
shell::eval shellrc::coding_setup

shellrc::terminal_setup() {
    if [ "$TERM" = "xterm" ]; then
        export TERM="xterm-256color"
    fi
}
shell::eval shellrc::terminal_setup

shellrc::dircolor_setup() {
    local dircolors_path="$HOME/.dircolors"

    if file::is_readable "${dircolors_path}"; then
        eval "$(dircolors -b ${dircolors_path})"
    else
        eval "$(dircolors -b)"
    fi
}
path::has_binary dircolors && shell::eval shellrc::dircolor_setup

shellrc::python_setup() {
    export VIRTUALENV_DISTRIBUTE=true

    if path::has_binary pip; then
        export PIP_REQUIRE_VIRTUALENV=true
        export PIP_DOWNLOAD_CACHE="$HOME/.cache/pip"
        syspip() {
            local args="${@}"
            local pipenv
            pipenv=( PIP_REQUIRE_VIRTUALENV="" )
            shell::exec_env $(shell::as_array pipenv) $(path::to pip) ${args}
        }
    fi
}
path::has_binary python && shell::eval shellrc::python_setup

shellrc::ruby_setup() {
    local rvm_script="$HOME/.rvm/scripts/rvm"
    shell::source "${rvm_script}"
}
shell::eval shellrc::ruby_setup

shellrc::editor_setup() {
    editor::setup
    export VISUAL="${EDITOR}"
    export GIT_EDITOR="${EDITOR}"
}
shell::eval shellrc::editor_setup

shellrc::alias_setup() {
    local alias_file="$HOME/.shell_aliases"
    shell::source "${alias_file}"
}
shell::eval shellrc::alias_setup

shellrc::fontconfig_setup() {
    local infinality_settings="$HOME/.dotfiles/external/fontconfig-ultimate/freetype/infinality-settings.sh"
    shell::source "${infinality_settings}"
}
shell::eval shellrc::fontconfig_setup

shellrc::tmux_setup() {
    path::has_binary tmuxifier && eval "$(tmuxifier init -)"
}
path::has_binary tmux && shell::eval shellrc::tmux_setup

# Load SSH module
path::has_binary ssh && shell::source "$HOME/.ssh/sh"
# Load less utilities
if path::has_binary less; then
    shell::source "$HOME/.local/lib/sh/less.sh"
    export PAGER=$(path::to less)
fi

shellrc::local_setup() {
    local local_profile="$HOME/.shellrc.local"
    local local_aliases="$HOME/.shell_aliases.local"
    shell::source "${local_profile}"
    shell::source "${local_aliases}"
}
shell::eval shellrc::local_setup

# Local Variables:
# mode: shell-script
# End:
