_shellrc_lib="${HOME}/.local/lib/sh"
_shellrc_libexec="${HOME}/.local/libexec/sh"

. "${_shellrc_lib}/print.sh"
. "${_shellrc_lib}/shell.sh"
. "${_shellrc_lib}/compat.sh"
. "${_shellrc_lib}/alist.sh"
. "${_shellrc_lib}/file.sh"
. "${_shellrc_lib}/string.sh"
. "${_shellrc_lib}/path.sh"
. "${_shellrc_lib}/os.sh"
. "${_shellrc_lib}/keyboard.sh"
. "${_shellrc_lib}/process.sh"
. "${_shellrc_lib}/service.sh"
. "${_shellrc_lib}/network.sh"
. "${_shellrc_lib}/mount.sh"
. "${_shellrc_lib}/alias.sh"
. "${_shellrc_lib}/url.sh"

shellrc::module::load() {
    local module="${1}"

    echo eval " \
    \$(shell::source ${_shellrc_libexec}/${module}.sh); \
    "
}

shellrc::path_setup() {
    path::prepend /usr/local/bin
    path::prepend /usr/local/sbin

    path::has_binary npm && path::prepend "$(npm prefix --global)/bin"
    path::prepend "/opt/cabal/bin"

    if os::is_darwin; then
        path::prepend /usr/texbin
        path::prepend /opt/X11/bin

        local server_prefix="/Applications/Server.app/Contents/ServerRoot"
        path::prepend "$server_prefix/bin"
        path::prepend "$server_prefix/sbin"

        if path::has_binary brew; then
            local brew_prefix="$(brew --prefix)"
            path::prepend "$brew_prefix/bin"
            path::prepend "$brew_prefix/sbin"

            for binary in ruby python python3 go; do
                if file::is_executable "${brew_prefix}/bin/${binary}"; then
                    path::prepend "$(brew --prefix ${binary})/bin"
                fi
            done
        fi
    fi

    path::prepend "${HOME}/.local/bin"
    path::prepend "${HOME}/.cask/bin"
    path::prepend "${HOME}/.cabal/bin"
    path::prepend "${HOME}/bin"
}
shell::eval shellrc::path_setup

shellrc::coding_setup() {
    export LANG="en_US.UTF_8"
    export LC_ALL="en_US.UTF-8"
    # Keep the default sort order (e.g. files starting with a '.'
    # should appear at the start of a directory listing.)
    export LC_COLLATE="C"
    # Set the short date to YYYY-MM-DD (test with "date +%c")
    export LC_TIME="sv_SE.UTF-8"
}
shell::eval shellrc::coding_setup

shellrc::terminal_setup() {
    if [ "$TERM" = "xterm" ]; then
        export TERM="xterm-256color"
    fi
}
shell::eval shellrc::terminal_setup

shellrc::alias_setup() {
    local alias_file="${HOME}/.shell_aliases"
    $(shell::source "${alias_file}")
}
shell::eval shellrc::alias_setup

###
# Setup modules.
$(shellrc::module::load editor)
$(shellrc::module::load connect)
os::is_linux && $(shellrc::module::load linux)
path::has_binary dircolors && $(shellrc::module::load dircolors)
path::has_binary fc-list && $(shellrc::module::load fontconfig)
path::has_binary ssh && $(shellrc::module::load ssh)
path::has_binary less && $(shellrc::module::load less)
path::has_binary gcc && $(shellrc::module::load gcc)
path::has_binary git && $(shellrc::module::load git)
path::has_binary tmux && $(shellrc::module::load tmux)
path::has_binary python && $(shellrc::module::load python)
path::has_binary ruby && $(shellrc::module::load ruby)
path::has_binary perl && $(shellrc::module::load perl)
path::has_binary ocaml && $(shellrc::module::load ocaml)
path::has_binary R && $(shellrc::module::load R)

###
# Load local configuration.
$(shell::source "${HOME}/.shellrc.local")
$(shell::source "${HOME}/.shell_aliases.local")

# Local Variables:
# mode: shell-script
# End:
